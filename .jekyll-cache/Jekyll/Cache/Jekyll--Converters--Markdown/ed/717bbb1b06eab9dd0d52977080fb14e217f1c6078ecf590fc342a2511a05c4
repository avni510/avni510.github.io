I"ÆP<p>There a few different ways to define polymorphic behavior in Clojure. The two main ways are through Multimethods and Protocols.</p>

<p>Lets first take a look at Multimethods</p>

<h4 id="multimethods">Multimethods</h4>

<p>Multimethods have something called a dispatch function which can be thought of like an air traffic controller. They determine where in the airport the plane should land based on various conditions and information. Multimethods work similarily in the way that there is one overarching dispatch function which makes a decision on which implementation to execute. Lets look at an example with Tic Tac Toe.</p>

<p>Iâ€™m working on having two different types of players a human and a computer. Each player should select a move in a different way. For the human the program should prompt the user for their input and for the computer it should generate a random number on the board. And for both a human or a computer I want a new board returned with their filled in move</p>

<p>Hereâ€™s my implementation of multimethods</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmulti</span><span class="w"> </span><span class="n">make-move</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">player-map</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="no">:player-type</span><span class="w"> </span><span class="n">player-map</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">make-move</span><span class="w"> </span><span class="no">:human</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">player-map</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
    </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="p">(</span><span class="nf">console-ui/get-user-input</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">board/fill-board</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="p">(</span><span class="no">:marker</span><span class="w"> </span><span class="n">player-map</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">computer-move</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">9</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">make-move</span><span class="w"> </span><span class="no">:computer</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">player-map</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
    </span><span class="p">(</span><span class="nf">computer-move</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">board/fill-board</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="p">(</span><span class="no">:marker</span><span class="w"> </span><span class="n">player-map</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">make-move</span><span class="w"> </span><span class="no">:default</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">player-map</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">console-ui/print-message</span><span class="w"> </span><span class="p">(</span><span class="nf">messages/invalid-player-type</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>There are a few core components to a multimethod. I have a dispatch function defined by <code class="language-plaintext highlighter-rouge">(defmulti make-move...)</code> which returns something called a dispatching value. In my case I am passing in a map to <code class="language-plaintext highlighter-rouge">make-move</code> which looks like this <code class="language-plaintext highlighter-rouge">{:player-type :human :marker :x}</code>. So my dispatch function is returning the dispatching value which would either be a <code class="language-plaintext highlighter-rouge">:human</code> or <code class="language-plaintext highlighter-rouge">:computer</code>. The keywords to the right of <code class="language-plaintext highlighter-rouge">defmethod</code> are called dispatch values which will match up with the dispatching value returned from <code class="language-plaintext highlighter-rouge">(defmulti make-move...)</code>. If the dispatching value is a <code class="language-plaintext highlighter-rouge">:human</code> it will ask the user for their input and fill in the board accordingly. If the dispatching value is a <code class="language-plaintext highlighter-rouge">:computer</code> it will compute a random move between 0-9 (exclusive) and return in a filled in value.</p>

<p>Hereâ€™s a visual of the vocabulary described above.</p>

<p><img src="/assets/multimethods.png" alt="multimethods" /></p>

<p>As a clarification the dispatch function will return a dispatching value that is then matched up with a dispatch value.</p>

<p>Essentially the dispatching function returns a value and that value is used to determine which method defintion should be used.</p>

<p>The last part</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">make-move</span><span class="w"> </span><span class="no">:default</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">player-map</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">console-ui/print-message</span><span class="w"> </span><span class="p">(</span><span class="nf">messages/invalid-player-type</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>is an exception case. If the dispatching function returns a value that doesnâ€™t exist the <code class="language-plaintext highlighter-rouge">:default</code> method implementation will be used.</p>

<p>Hereâ€™s an example of how it works</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:player-type</span><span class="w"> </span><span class="no">:human</span><span class="w"> </span><span class="no">:marker</span><span class="w"> </span><span class="no">:x</span><span class="p">})</span><span class="w">
</span><span class="c1">; asks for the user input and the user enters 5</span><span class="w">
 </span><span class="mi">5</span><span class="w">
</span><span class="c1">; [0 1 2 3 4 :x 6 7 8]</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:player-type</span><span class="w"> </span><span class="no">:computer</span><span class="w"> </span><span class="no">:marker</span><span class="w"> </span><span class="no">:x</span><span class="p">})</span><span class="w">
</span><span class="c1">; generates a random move and fills in the board</span><span class="w">
</span><span class="c1">; [0 1 2 3 :x 5 6 7 8]</span><span class="w">
</span></code></pre></div></div>

<p>The next way is through protocols.</p>

<h4 id="protocols">Protocols</h4>

<p>Protocols are more similar to an object orientated way of solving polymorphism. Where as the multimethod is just one polymorphic operation a protocol offers the flexibility of implementing a collection of one or more polymorphic functions. Protocols are setup in a similar way to interfaces in Java. The first argument works like the dispatching value in multimethods. It determines which behavior of the function to use.</p>

<p>Hereâ€™s an example of how the same functionality from the multimethods example would be implemented through a protocol.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defprotocol</span><span class="w"> </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftype</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="w">
  </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
      </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="p">(</span><span class="nf">console-ui/get-user-input</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">board/fill-board</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">marker</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">computer-move</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">9</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftype</span><span class="w"> </span><span class="n">Computer</span><span class="w"> </span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="w">
  </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
      </span><span class="p">(</span><span class="nf">computer-move</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">board/fill-board</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">marker</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>In the protocol example weâ€™re also using <code class="language-plaintext highlighter-rouge">deftype</code> which in my example above are used similar to classes in an OOP that implement an interface. Here I have two types either a Human or Computer that each implement the protocol and the corresponding method in the protocol - <code class="language-plaintext highlighter-rouge">make-move</code>.</p>

<p>Hereâ€™s an example of how it can be called</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">(</span><span class="nf">Human.</span><span class="w"> </span><span class="no">:x</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="p">])</span><span class="w">
</span><span class="c1">; asks for the user input and the user enters 5</span><span class="w">
 </span><span class="mi">5</span><span class="w">
</span><span class="c1">; [0 1 2 3 4 :x 6 7 8]</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">(</span><span class="nf">Computer.</span><span class="w"> </span><span class="no">:x</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="p">])</span><span class="w">
</span><span class="c1">; generates a random move and fills in the board</span><span class="w">
</span><span class="c1">; [0 1 :x 3 4 5 6 7 8]</span><span class="w">
</span></code></pre></div></div>

<p>Another neat thing about a protocol is you can have a varying degree of arguments as long as it specified in the protocol. For example</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defprotocol</span><span class="w"> </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">player-num</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">deftype</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="w">
  </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">player-num</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
      </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="p">(</span><span class="nf">console-ui/get-user-input</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">board/fill-board</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">marker</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftype</span><span class="w"> </span><span class="n">Computer</span><span class="w"> </span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="w">
  </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
      </span><span class="p">(</span><span class="nf">computer-move</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">board/fill-board</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">marker</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>
<p>Here we have specified that <code class="language-plaintext highlighter-rouge">make-move</code> can take either two arguments or three arguments.</p>

<p>A note of restriction for protocols is that must implement all the methods from your protocol.</p>

<p>If I had something like this</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defprotocol</span><span class="w"> </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="p">])</span><span class="w">
  </span><span class="p">(</span><span class="nf">print-player-type</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">deftype</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="w">
  </span><span class="n">Move</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-move</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">board</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
      </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="p">(</span><span class="nf">console-ui/get-user-input</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">board/fill-board</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">marker</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>it would be violation since <code class="language-plaintext highlighter-rouge">(deftype Human)</code> does not implement the method <code class="language-plaintext highlighter-rouge">(print-player-type)</code>.</p>

<p>Both multimethods and protocols acheive polymorphism behavior in Clojure. Mutlimethods tend to be a more functional approach  where as protocols tend to be a more object orientated way to solving the problem.</p>

:ET