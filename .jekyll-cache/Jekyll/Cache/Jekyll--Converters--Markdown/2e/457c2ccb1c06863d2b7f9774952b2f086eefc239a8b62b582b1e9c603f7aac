I"±|<p>My post a few weeks ago about implementing minimax in Clojure was written in a linear recursive way. Another way to write the same algothrim is in a tail recursive manner. Both have their pluses and minuses which I‚Äôll discuss further into the post. But I want to go through a brief explantation on how to think about this algothrim tail recursively.</p>

<p>The main difference between the two different types of recursion is that with linear recursion the stack frames continue to grow on the call stack until the base case is hit, in which case it‚Äôll then pop each recursive call off the stack and evaluate them. The general shape of the process of evaluation for linear recursion can be thought of as a bell curve. By contrast, tail recursion passes the results from the current recursive call to the next recursive call. The function keeps track of its return value as it goes along. This can be thought of as accumulation value. The general shape of the process of evaluation can be thought out a straight down line. Some languages, like Clojure, are optimizied for tail recursion, while others are not.</p>

<p>With minimax, I approached this problem by thinking about what I want to keep track of in the tree. I know the nodes in the tree are boards representing each game state, so between each node I want pass up the score of the current node to the parent node and the optimal score is then calculated for the parent node (either the max of min score depending on which kind of node it is).</p>

<p><img src="/assets/tail_recursive_tree.png" alt="tail_recursive_tree" /></p>

<p>The circles can be thought of as nodes (which in my case are boards), and the blue circles can be thought of as max nodes (calculating the max of their subtree) while the green circles can be thought of as min nodes (calculating the min of their subtree).</p>

<p>Here‚Äôs the order the computer would evaluate this kind of tree</p>

<ol>
  <li>Continue to go down the tree until it hits a terminal node</li>
  <li>Get the value or the score of the terminal node</li>
  <li>Pass back the current node‚Äôs score to the parent node</li>
  <li>Replace the parent node‚Äôs score if the current node‚Äôs score is the optimal score</li>
</ol>

<p>As you can see at each node, we‚Äôre keeping track of the best possible score hence why we need to implement this tail recursively.</p>

<p>I also decided that the default score for a max node is -100 and for a min node is 100. I chose these values because that‚Äôs the worst possible score each respective node could have and it makes it easier for calculation purposes. Also, what we finally want returned from the algothrim is not the score but the space. So we need to make sure if we are at the root node and the entire tree has been traversed that we return the best space rather than the best score.</p>

<p>Unfortunately, with an algothrim like minimax there‚Äôs a lot of conditions and a lot to keep track of so this implementation takes in a lot of parameters.</p>

<p>There‚Äôs a few conditions we have to keep in mind:</p>
<ul>
  <li>If the algothrim is at a root node and the whole tree is traversed -&gt; return the space</li>
  <li>If the algothrim is at a terminal node -&gt; figure out if the parent‚Äôs score needs to be replaced</li>
  <li>If the algothrim is at a node where the children are traversed -&gt; figure out if the parent‚Äôs score needs to be replaced</li>
  <li>If the algothrim is at an intermediate node and none of the children are traversed -&gt; traverse the children</li>
</ul>

<p>I decided to keep track of all the parameters with a map. And I call it accumulator because it represents the accumulated best score at each node (which is a board).</p>

<p>accumulator</p>
<ul>
  <li>board-and-space (this is a hash map, and it is the current node‚Äôs board and space)</li>
  <li>score (represents optimal score of the current node‚Äôs)</li>
  <li>depth (represents the current node‚Äôs depth)</li>
  <li>parent_accumulator (represents the current node‚Äôs parent node - it has the same keys as accumulator although different values to represent the parent)</li>
  <li>children (is a sequence of all my children nodes - which are boards)</li>
  <li>markers (is a map that contains the computer marker and the human marker)</li>
</ul>

<p>Here‚Äôs some pseudo code for the algothrim. I wrote some comments in first person, with the perspective that ‚ÄúI‚Äù represents the current node</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tail-minimax</span><span class="w"> </span><span class="p">[</span><span class="n">accumulator</span><span class="p">]</span><span class="w">
  </span><span class="c1">; if I am the root node and whole tree has been traversed</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.depth</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="n">accumulator.children</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">empty</span><span class="w">
    </span><span class="n">return</span><span class="w"> </span><span class="n">space</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">score</span><span class="w">

  </span><span class="c1">; if I am the terminal node or all the children have been traversed</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.board</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">terminal</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="nb">or</span><span class="w"> </span><span class="n">accumulator.children</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">empty</span><span class="err">:</span><span class="w">

      </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">MIN</span><span class="w"> </span><span class="nb">node</span><span class="w">
        </span><span class="c1">; if my score is better than my parent's score </span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w"> </span><span class="nb">&lt;</span><span class="w"> </span><span class="n">parent_accumulator.score</span><span class="w">
          </span><span class="c1">; the root node needs to know the best space so I pass my space to the root node</span><span class="w">
          </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.depth</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
             </span><span class="n">parent_accumulator.score</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w">
             </span><span class="n">parent_accumulator.space</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">accumulator.space</span><span class="w">
          </span><span class="c1">; if my parent is an intermediate node I just need to replace my parent's score</span><span class="w">
          </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.depth</span><span class="w"> </span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
             </span><span class="n">parent_accumulator.score</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w">
          </span><span class="c1">; call back the function with my parent but I have already been traversed</span><span class="w">
          </span><span class="n">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">parent_accumulator</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">parent_accumulator.children</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">parent_accumulator.children</span><span class="p">))</span><span class="w">
        </span><span class="c1">; if my score is not better than my parent's score - do not replace it, but call my parent to traverse the remaining children</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w"> </span><span class="nb">&gt;</span><span class="w"> </span><span class="n">parent_accumulator.score</span><span class="w">
          </span><span class="n">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">parent_accumulator</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">parent_accumulator.children</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">parent_accumulator.children</span><span class="p">))</span><span class="w">

      </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">MAX</span><span class="w"> </span><span class="nb">node</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w"> </span><span class="nb">&gt;</span><span class="w"> </span><span class="n">parent_accumulator.score</span><span class="w">
          </span><span class="k">if</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
            </span><span class="n">parent_accumulator.score</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w">
            </span><span class="n">parent_accumulator.space</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">accumulator.space</span><span class="w">
          </span><span class="k">if</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
             </span><span class="n">parent_accumulator.score</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w">
          </span><span class="n">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">parent_accumulator</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">parent_accumulator.children</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">parent_node.children</span><span class="p">))</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="n">accumulator.score</span><span class="w"> </span><span class="nb">&lt;</span><span class="w"> </span><span class="n">parent_node.score</span><span class="w">
          </span><span class="n">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">parent_accumulator</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">parent_accumulator.children</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">parent_node.children</span><span class="p">))</span><span class="w">

    </span><span class="c1">; if I am an intermediate node and I still have children I have not traversed</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">accumulator</span><span class="ss">'s</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">intermediate</span><span class="w"> </span><span class="nb">node</span><span class="err">:</span><span class="w">
      </span><span class="n">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">accumulator.children</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>I realize this is a mess and very difficult to read. So I‚Äôve tried to space it out into the main conditions which are then followed by subconditions.</p>

<p>This pseudo code is pretty thorough (maybe a bit too much) the rest is just a matter of putting it into the Clojure language.</p>

<p>Here‚Äôs the final implementation</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">best-move</span><span class="w"> </span><span class="p">(</span><span class="nf">memoize</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">accumulator</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="p">(</span><span class="no">:board</span><span class="w"> </span><span class="p">(</span><span class="no">:board-and-space</span><span class="w"> </span><span class="n">accumulator</span><span class="p">))</span><span class="w">
        </span><span class="n">space</span><span class="w"> </span><span class="p">(</span><span class="no">:space</span><span class="w"> </span><span class="p">(</span><span class="no">:board-and-space</span><span class="w"> </span><span class="n">accumulator</span><span class="p">))</span><span class="w">
        </span><span class="n">depth</span><span class="w"> </span><span class="p">(</span><span class="no">:depth</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)</span><span class="w">
        </span><span class="n">alpha</span><span class="w"> </span><span class="p">(</span><span class="no">:alpha</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)</span><span class="w">
        </span><span class="n">beta</span><span class="w"> </span><span class="p">(</span><span class="no">:beta</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)</span><span class="w">
        </span><span class="n">parent-accumulator</span><span class="w"> </span><span class="p">(</span><span class="no">:parent-accumulator</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)</span><span class="w">
        </span><span class="nb">children</span><span class="w"> </span><span class="p">(</span><span class="no">:children</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)</span><span class="w">
        </span><span class="n">computer-marker</span><span class="w"> </span><span class="p">(</span><span class="no">:computer-marker</span><span class="w"> </span><span class="p">(</span><span class="no">:markers</span><span class="w"> </span><span class="n">accumulator</span><span class="p">))</span><span class="w">
        </span><span class="n">opponent-marker</span><span class="w"> </span><span class="p">(</span><span class="no">:opponent-marker</span><span class="w"> </span><span class="p">(</span><span class="no">:markers</span><span class="w"> </span><span class="n">accumulator</span><span class="p">))]</span><span class="w">

    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="nb">children</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:score</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)</span><span class="w"> </span><span class="n">best-possible-score</span><span class="p">)))</span><span class="w">
      </span><span class="n">space</span><span class="w">
      </span><span class="p">(</span><span class="nf">do</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">game-evaluation/game-over?</span><span class="w"> </span><span class="n">board</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="nb">children</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="n">alpha</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">score</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">game-evaluation/game-over?</span><span class="w"> </span><span class="n">board</span><span class="p">)</span><span class="w">
                        </span><span class="p">(</span><span class="nf">calculate-score</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">computer-marker</span><span class="w"> </span><span class="n">opponent-marker</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w">
                        </span><span class="p">(</span><span class="no">:score</span><span class="w"> </span><span class="n">accumulator</span><span class="p">))]</span><span class="w">
            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="p">(</span><span class="no">:score</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
                  </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="w"> </span><span class="no">:children</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="no">:children</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:score</span><span class="w"> </span><span class="n">score</span><span class="w">
                                                   </span><span class="no">:beta</span><span class="w"> </span><span class="p">(</span><span class="nb">min</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="p">(</span><span class="no">:beta</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:board-and-space</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">(</span><span class="no">:board-and-space</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">)</span><span class="w">
                                                                           </span><span class="no">:space</span><span class="w"> </span><span class="n">space</span><span class="p">)))</span><span class="w">
                  </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="w"> </span><span class="no">:children</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="no">:children</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:beta</span><span class="w"> </span><span class="p">(</span><span class="nb">min</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="p">(</span><span class="no">:beta</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:score</span><span class="w"> </span><span class="n">score</span><span class="p">)))</span><span class="w">
                </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="w"> </span><span class="no">:children</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="no">:children</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">)))))</span><span class="w">
              </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="p">(</span><span class="no">:score</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
                  </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="w"> </span><span class="no">:children</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="no">:children</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:score</span><span class="w"> </span><span class="n">score</span><span class="w">
                                                   </span><span class="no">:alpha</span><span class="w"> </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="p">(</span><span class="no">:alpha</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:board-and-space</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">(</span><span class="no">:board-and-space</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">)</span><span class="w">
                                                                           </span><span class="no">:space</span><span class="w"> </span><span class="n">space</span><span class="p">)))</span><span class="w">
                  </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="w"> </span><span class="no">:children</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="no">:children</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:alpha</span><span class="w"> </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="p">(</span><span class="no">:alpha</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">))</span><span class="w">
                                                   </span><span class="no">:score</span><span class="w"> </span><span class="n">score</span><span class="p">)))</span><span class="w">
                </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="w"> </span><span class="no">:children</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="no">:children</span><span class="w"> </span><span class="n">parent-accumulator</span><span class="p">)))))))</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">{</span><span class="no">:board-and-space</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nb">children</span><span class="p">)</span><span class="w">
                  </span><span class="no">:score</span><span class="w"> </span><span class="p">(</span><span class="nf">determine-initial-score</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">depth</span><span class="p">))</span><span class="w">
                  </span><span class="no">:depth</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w">
                  </span><span class="no">:alpha</span><span class="w"> </span><span class="n">alpha</span><span class="w">
                  </span><span class="no">:beta</span><span class="w"> </span><span class="n">beta</span><span class="w">
                  </span><span class="no">:parent-accumulator</span><span class="w"> </span><span class="n">accumulator</span><span class="w">
                  </span><span class="no">:children</span><span class="w"> </span><span class="p">(</span><span class="nf">generate-boards</span><span class="w"> </span><span class="p">(</span><span class="nf">determine-player-marker</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w">
                                                                      </span><span class="n">computer-marker</span><span class="w">
                                                                      </span><span class="n">opponent-marker</span><span class="p">)</span><span class="w">
                                             </span><span class="p">(</span><span class="no">:board</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nb">children</span><span class="p">)))</span><span class="w">
                  </span><span class="no">:markers</span><span class="w"> </span><span class="p">(</span><span class="no">:markers</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)}))))))))</span><span class="w">
</span></code></pre></div></div>

<p>An extremely large function. Testing this was difficult. I ran through multiple different types of board scenarios and drew out a tree on paper and had a bunch of print statements in my function to verify that I was getting the correct results. But to really thoroughly test it you can generate all possible end game states and double check that the computer never loses (the game is either won by the computer or is tied).</p>

<p>So which implemention do we pick? The linear recursive way or the tail recursive way?</p>

<p>The tail recursive way is much slower. There are many more recursive calls to the function than the linear recursive way. To go back to the picture above, there are 5 recursive calls for 3 nodes until the best move is returned. But the amount of memory that is used is much lower than the linear recursive version. This is because we are keeping track of the best score as we go along, rather than waiting till the end to evaluate it. So it depends which one you‚Äôre willing to let go on - speed or memory. Although the tail recursive version is slower there is a way to optimize it with alpha beta pruning.</p>

:ET