I"¦<p>If you are using a database for your application you are probably writing some tests to verify the correct results are written to your database. In my case, I set up a test database that I write results out to and verify the results. I initially made the mistake of not cleaning my test database after each test and ran into the same result being added to my database mulitple times. I then started to realize the importance of database cleaning for your tests - it allows each test to be run independently of each other. I started looking into different database cleaning methods and here are a few I found:</p>

<p><strong>Deletion</strong></p>

<p>This cleaning mechansim uses SQLâ€™s <code class="language-plaintext highlighter-rouge">DELETE FROM &lt;table_name&gt;</code> statement. This will delete one row at a time in the table. Generally causing it to be one of the slower Database Cleaning methods. <code class="language-plaintext highlighter-rouge">DELETE FROM</code> also allows the usage of a where clause to elminate specific entries ex: <code class="language-plaintext highlighter-rouge">DELETE FROM USERS WHERE id=1</code> will only delete the row where id is 1. If you have an auto incrementer for the ID column <code class="language-plaintext highlighter-rouge">DELETE FROM</code> will not reset the auto incremeter. Another statement has to be run in order to do so.</p>

<p><strong>Truncation</strong></p>

<p>This uses SQLâ€™s <code class="language-plaintext highlighter-rouge">TRUNCATE TABLE &lt;table_name&gt;</code> statement. It will delete all the rows from the table specified. Contrary to the <code class="language-plaintext highlighter-rouge">DELETE FROM</code> statement <code class="language-plaintext highlighter-rouge">TRUNCATE TABLE</code> does not allow the specification of a where clause. Either all entries go or none. An advantage of truncation is that after deleting all the rows if you have an ID column that is auto incremented, it will be reset. But beware because <code class="language-plaintext highlighter-rouge">TRUNCATE TABLE &lt;table_name&gt;</code> cannot be used on tables with a foreign key reference. Here is an example. Lets say we have a Users table</p>

<p><img src="https://avni510.github.io/assets/db_truncation_before_table.png" alt="before_truncation" /></p>

<p>We can run the statement <code class="language-plaintext highlighter-rouge">TRUNCATE TABLE USERS;</code></p>

<p>And all rows in the table are deleted (this statement works because there is no foreign key reference to any of the columns in Users)</p>

<p><img src="https://avni510.github.io/assets/db_truncation_after_table.png" alt="after_truncation" /></p>

<p><strong>Transaction</strong></p>

<p>This will use SQLâ€™s <code class="language-plaintext highlighter-rouge">BEGIN</code> statement. This allows you to, in a sense, protect the following commands you write. I think itâ€™s easiest to see how <code class="language-plaintext highlighter-rouge">BEGIN</code> works by an example. Lets say we have an Employees table that looks like this:</p>

<p><img src="https://avni510.github.io/assets/db_transaction_before_table.png" alt="before_transaction" /></p>

<p>Then we run a series of commands starting with the <code class="language-plaintext highlighter-rouge">BEGIN</code> statement and then updating an employee name</p>

<p><img src="https://avni510.github.io/assets/db_transaction_commands.png" alt="transaction_commands" /></p>

<p>Our Employees table now looks like this</p>

<p><img src="https://avni510.github.io/assets/db_after_transaction.png" alt="after_transaction" /></p>

<p>But perhaps we made a mistake and didnâ€™t mean to update that specific employee and it should have instead been another employee.</p>

<p>We can easily run <code class="language-plaintext highlighter-rouge">ROLLBACK;</code> and all our changes (inside the <code class="language-plaintext highlighter-rouge">BEGIN</code> block) will be deleted.</p>

<p><img src="https://avni510.github.io/assets/db_transaction_before_table.png" alt="before_transaction" /></p>

<p>Or we can run <code class="language-plaintext highlighter-rouge">COMMIT;</code> and all the changes we made (inside the <code class="language-plaintext highlighter-rouge">BEGIN</code> block) will be saved. Transactions are particularly useful if youâ€™re making a large change and want to double check that the command you entered will make the correct changes to your database. This is also probably the most frequently used cleaning method as it is generally the fastest.</p>

<p>For Rspec there is a gem called <a href="https://github.com/DatabaseCleaner/database_cleaner">Database Cleaner</a> that uses the strategies listed above to clean your database for your test suite.</p>

:ET